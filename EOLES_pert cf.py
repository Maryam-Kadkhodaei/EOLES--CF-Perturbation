"""
Eoles Model from Behrang Shirizadeh, Quentin Perrier and Philippe Quirion, May 2021
Written in Python by Nilam De Oliveira-Gill, June 2021
"""

import pyomo.environ as pyo
from pyomo.opt import SolverFactory
import pandas as pd
import csv
import time
import sys


number_of_years = 9
# Initialize time
start_time = time.time()
# Redirect stdout
sys.stdout = open("stdout.txt", 'a')

"""INITIALISATION MODEL"""

model = pyo.ConcreteModel()

# Dual Variable, used to get the marginal value of an equation.
model.dual = pyo.Suffix(direction=pyo.Suffix.IMPORT)

"""INPUTS"""
# Production profiles of VRE
#load_factor = pd.read_csv("inputs/vre_obs_pv_wind.csv", index_col=[0, 1],  header=None)
#load_factor = load_factor.squeeze()


# Demand profile in each our in GW
demand = pd.read_csv("inputs/demand_2012_2020.csv", index_col=0,  header=None)
demand = demand.squeeze()

# Monthly lake inflows in GWh
lake_inflows = pd.read_csv("inputs/lake2006_nine.csv", index_col=0,  header=None)
lake_inflows = lake_inflows.squeeze()

# existing capacities of the technologies by December 2017 in GW
capa_ex = pd.read_csv("inputs/existing_capas_elec_new_NoOffshore_voll.csv", index_col=0,  header=None)
capa_ex = capa_ex.squeeze()

# maximum capacities of the technologies in GW
capa_max = pd.read_csv("inputs/max_capas_elec_new_NoOffshore.csv", index_col=0,  header=None)
capa_max = capa_max.squeeze()

# annualized power capex cost in M€/GW/year
capex = pd.read_csv("inputs/annuities_elec_new_NoOffshore_voll.csv", index_col=0,  header=None)
capex = capex.squeeze()

# annualized energy capex cost of storage technologies in M€/GWh/year
capex_en = pd.read_csv("inputs/str_annuities_elec_new.csv", index_col=0,  header=None)
capex_en = capex_en.squeeze()

# annualized fixed operation and maintenance costs M€/GW/year
fOM = pd.read_csv("inputs/fO&M_elec_new_NoOffshore_voll.csv", index_col=0,  header=None)
fOM = fOM.squeeze()

# Variable operation and maintenance costs in M€/GWh
vOM = pd.read_csv("inputs/vO&M_elec_new_NoOffshore_voll.csv", index_col=0,  header=None)
vOM = vOM.squeeze()

# charging related annuity of storage in M€/GW/year
s_capex = pd.read_csv("inputs/s_capex.csv", index_col=0, header=None)
s_capex = s_capex.squeeze()

# charging related fOM of storage in M€/GW/year
s_opex = pd.read_csv("inputs/s_opex.csv", index_col=0,  header=None)
s_opex = s_opex.squeeze()

# charging efficiency of storage technologies
eta_in = pd.read_csv("inputs/eta_in.csv", index_col=0,  header=None)
eta_in = eta_in.squeeze()

# discharging efficiency of storage technolgoies
eta_out = pd.read_csv("inputs/eta_out.csv", index_col=0,  header=None)
eta_out = eta_out.squeeze()

# existing storage capacity in GWh
capacity_ex = pd.read_csv("inputs/capacity_ex.csv", index_col=0,  header=None)
capacity_ex = capacity_ex.squeeze()

# Parameters in miscellaneous.csv :
# eta_ocgt                  : efficiency of OCGT power plants
# eta_ccgt                  : efficiency of CCGT power plants with CCS
# max_biogas                : maximum energy can be generated by biogas in TWh
# load_uncertainty          : uncertainty coefficient for hourly demand
# delta                     : load variation factor
# phs_discharging_lower     : lower bounds for capa(phs)
# phs_discharging_upper     : upper bounds for capa(phs)
# phs_charging_lower        : lower bounds for s(phs)
# phs_charging_upper        : upper bounds for s(phs)
# phs_energy_lower          : lower bounds for capacity(phs)
# phs_energy_upper          : upper bounds for capacity(phs)
# first_month               : first month of demand
# first_year                : first year of demand

miscellaneous = pd.read_csv("inputs/miscellaneous_noHdemand.csv", index_col=0, header=None)
miscellaneous = miscellaneous.squeeze()

"""SET HOUR BY MONTHS

Take the number of hour in the demand file.
Set up hours per months. Take care of leap years."""

first_year = miscellaneous['first_year']
first_month = miscellaneous['first_month']
first_hour = 0
last_hour = len(demand)
days_in_feb = 672
if first_year % 4 == 0:
    days_in_feb = 696

months_count = 12*number_of_years

hours_by_months = {1: 744, 2: days_in_feb, 3: 744, 4: 720, 5: 744, 6: 720, 7: 744, 8: 744, 9: 720, 10: 744, 11: 720,
                   12: 744}
months_hours = {1: range(0, 744), 2: range(744, 1440), 3: range(1440, 2184), 4: range(2184, 2904),
                5: range(2904, 3648), 6: range(3648, 4368), 7: range(4368, 5112),
                8: range(5112, 5856), 9: range(5856, 6576), 10: range(6576, 7320), 11: range(7320, 8040),
                12: range(8039, last_hour)}
i = 1
j = first_month
hour = 0

while i <= months_count:
    months_hours[i] = range(hour, hour + hours_by_months[j])
    hour += hours_by_months[j]
    j += 1
    i += 1
    if j == 13:
        j = 1

"""SETS"""

# Range of hour in one year
model.h = \
    pyo.RangeSet(first_hour, last_hour - 1)
# Months
model.months = \
    pyo.RangeSet(1, months_count)
# Technologies
model.tec = \
    pyo.Set(
        initialize=["onshore", "pv_g", "pv_c", "river", "lake", "biogas2", "ccgt", "nuc",
                    "phs", "battery4", "ll"])
# Power plants
model.gen = \
    pyo.Set(initialize=["onshore", "pv_g", "pv_c", "river", "lake","ccgt", "nuc", "ll"])
# Variables Technologies
model.vre = \
    pyo.Set(initialize=["onshore", "pv_g", "pv_c", "river"])
#
model.balance = \
    pyo.Set(
        initialize=["onshore", "pv_g", "pv_c", "river", "lake", "nuc", "phs", "battery4",
                    "ccgt", "ll"])
# Storage Technologies
model.str = \
    pyo.Set(initialize=["phs", "battery4"])
# Storage Technologies
model.str_noH2 = \
    pyo.Set(initialize=["phs", "battery4"])
# Battery Storage
model.battery = \
    pyo.Set(initialize=[ "battery4"])


"""PARAMETERS"""

H2_demand = {}
for hour in model.h:
    H2_demand[hour] = miscellaneous['H2_demand']

"""INITIAL VALUES"""


def capa_bounds(model, i):
    if i == 'phs':
        return (miscellaneous['phs_discharging_lower'], miscellaneous['phs_discharging_upper'])
    elif i in model.vre:
        return (None, capa_max[i])
    else:
        return (None, None)


def s_bounds(model, i):
    if i == 'phs':
        return (miscellaneous['phs_charging_lower'], miscellaneous['phs_charging_upper'])
    else:
        return (None, None)


def capacity_bounds(model, i):
    if i == 'phs':
        return (miscellaneous['phs_energy_lower'], miscellaneous['phs_energy_upper'])

    else:
        return (None, None)


"""VARIABLES"""

# Hourly energy generation in GWh/h
model.gene = \
    pyo.Var(((tec, h) for tec in model.tec for h in model.h), within=pyo.NonNegativeReals, initialize=0)

# Overall yearly installed capacity in GW
model.capa = \
    pyo.Var(model.tec, within=pyo.NonNegativeReals, bounds=capa_bounds)

# Hourly electricity input of battery storage GW
model.storage = \
    pyo.Var(((storage, h) for storage in model.str for h in model.h), within=pyo.NonNegativeReals, initialize=0)

# Energy stored in each storage technology in GWh = Stage of charge
model.stored = \
    pyo.Var(((storage, h) for storage in model.str for h in model.h), within=pyo.NonNegativeReals, initialize=0)

# Charging power capacity of each storage technology
model.s = \
    pyo.Var(model.str, within=pyo.NonNegativeReals, initialize=0, bounds=capa_bounds)

# Energy volume of storage technology in GWh
model.capacity = \
    pyo.Var(model.str, within=pyo.NonNegativeReals, initialize=0, bounds=capacity_bounds)



"""FIXED VALUES"""

model.capa['lake'].fix(capa_ex['lake'])
model.capa['river'].fix(capa_ex['river'])

"""CONSTRAINTS RULE"""


def generation_vre_constraint_rule(model, h, vre):
    """Get constraint on variables renewable profiles generation.

    :param model: Model.
    :param h: Timestamp.
    :param tec: VRE Technology.
    :type model: :py:class:`pyomo.Model`
    :type h: :py:class:`pyomo.Set`
    :type vre: :py:class:`pyomo.Set`

    :returns: Expression.
    """
    return model.gene[vre, h] == model.capa[vre] * load_factor[vre, h]


def generation_capacity_constraint_rule(model, h, tec):
    """Get constraint on maximum power for non-VRE technologies.

    :param model: Model.
    :param h: Timestamp.
    :param tec: Technology.
    :type model: :py:class:`pyomo.Model`.
    :type h: :py:class:`pyomo.Set`
    :type tec: :py:class:`pyomo.Set`

    :returns: Expression.
    """
    return model.capa[tec] >= model.gene[tec, h]




def battery4_capacity_constraint_rule(model):
    """Get constraint on capacity of battery4.

    :param model: Model.
    :type model: :py:class:`pyomo.Model`

    :returns: Expression.
    """
    return model.capa['battery4'] == model.capacity['battery4'] / 4



def combustion_2_constraint_rule(model, h):
    """Get constraint on the relationship of combustible technologies

    :param model: Model.
    :param h: Timestamp.
    :type model: :py:class:`pyomo.Model`
    :type h: :py:class:`pyomo.Set`

    :returns: Expression.
    """
    return model.gene['ccgt', h] == model.gene['biogas2', h] * miscellaneous['eta_ccgt']



def storing_constraint_rule(model, h, storage_tecs):
    """Get constraint on storing.

    :param model: Model.
    :param h: Timestamp.
    :param storage_tecs: Storage Technologies.
    :type model: :py:class:`pyomo.Model`
    :type h: :py:class:`pyomo.Set`
    :type storage_tecs: :py:class:`pyomo.Set`

    :returns: Expression.
    """
    hPOne = h + 1 if h < (last_hour - 1) else 0
    charge = model.storage[storage_tecs, h] * eta_in[storage_tecs]
    discharge = model.gene[storage_tecs, h] / eta_out[storage_tecs]
    flux = charge - discharge
    return model.stored[storage_tecs, hPOne] == model.stored[storage_tecs, h] + flux


def storage_constraint_rule(model, storage_tecs):
    """Get constraint on stored energy to be equal at the end than at the start.

    :param model: Model.
    :param storages_tecs: Storage Technology.
    :type model: :py:class:`pyomo.Model`
    :type storage_tecs: :py:class:`pyomo.Set`

    :returns: Expression.
    """
    first = model.stored[storage_tecs, first_hour]
    last = model.stored[storage_tecs, last_hour - 1]
    charge = model.storage[storage_tecs, last_hour - 1] * eta_in[storage_tecs]
    discharge = model.gene[storage_tecs, last_hour - 1] / eta_out[storage_tecs]
    flux = charge - discharge
    return first == last + flux


def lake_reserve_constraint_rule(model, month):
    """Get constraint on maximum monthly lake generation.

    :param model: Model.
    :param month: Month.
    :type model: :py:class:`pyomo.Model`
    :type month: int

    :returns: Expression.
    """
    return sum(model.gene['lake', hour] for hour in months_hours[month]) <= lake_inflows[month] * 1000


def stored_capacity_constraint(model, h, storage_tecs):
    """Get constraint on maximum energy that is stored in storage units

    :param model: Model.
    :param h: Timestamp.
    :param storage_tecs: Storage Technologies.
    :type model: :py:class:`pyomo.Model`
    :type h: :py:class:`pyomo.Set`
    :type storage_tecs: :py:class:`pyomo.Set`

    :returns: Expression.
    """
    return model.stored[storage_tecs, h] <= model.capacity[storage_tecs]


def storage_capacity_1_constraint_rule(model, h, storage_tecs):
    """Get constraint on the capacity with hourly charging relationship of storage

    :param model: Model.
    :param h: Timestamp.
    :param storage_tecs: Storage Technologies.
    :type model: :py:class:`pyomo.Model`
    :type h: :py:class:`pyomo.Set`
    :type storage_tecs: :py:class:`pyomo.Set`

    :returns: Expression.
    """
    return model.s[storage_tecs] >= model.storage[storage_tecs, h]


def battery_capacity_constraint_rule(model, battery):
    """Get constraint on battery's capacity.

    :param model: Model.
    :param battery: Battery
    :type model: :py:class:`pyomo.Model`
    :type battery: :py:class:`pyomo.Set`

    :returns: Expression.
    """
    return model.s[battery] == model.capa[battery]


def biogas_constraint_rule(model):
    """Get constraint on biogas.

  #  :param model: Model.
  #  :type model: :py:class:`pyomo.Model`

   # :returns: Expression.
    #"""
    gene_biogas = sum(model.gene['biogas2', hour] for hour in model.h)

    return gene_biogas <= miscellaneous['max_biogas'] * 1000*number_of_years






def adequacy_constraint_rule(model, h):
    """Get constraint for 'supply/demand relation'

    :param model: Model.
    :param h: Timestamp.
    :type model: :py:class:`pyomo.Model`
    :type h: :py:class:`pyomo.Set`

    :returns: Expression.
    """
    sto = sum(model.storage[str_noH2, h] for str_noH2 in model.str_noH2)
    return sum(model.gene[balance, h] for balance in model.balance) >= (demand[h] + sto )


def objective_rule(model):
    """Get constraint for the final objective function.

    :param model: Model.
    :type model: pyomo.Model

    :returns: Expression.
    """
    return (sum((model.capa[tec] - capa_ex[tec]) * capex[tec] * number_of_years for tec in model.tec) \
            + sum((model.capacity[storage_tecs] - capacity_ex[storage_tecs]) * capex_en[storage_tecs] * number_of_years
                  for storage_tecs in model.str) \
            + sum(model.capa[tec] * fOM[tec] * number_of_years for tec in model.tec) \
            + sum(model.s[storage_tecs] * (s_opex[storage_tecs] + s_capex[storage_tecs]) * number_of_years for
                  storage_tecs in model.str) \
            + sum(sum(model.gene[tec, h] * vOM[tec] for h in model.h) for tec in model.tec)) / 1000

fixed_cost = (sum((model.capa[tec] - capa_ex[tec]) * capex[tec] * number_of_years for tec in model.tec) \
            + sum((model.capacity[storage_tecs] - capacity_ex[storage_tecs]) * capex_en[storage_tecs] * number_of_years
                  for storage_tecs in model.str) \
            + sum(model.capa[tec] * fOM[tec] * number_of_years for tec in model.tec) \
            + sum(model.s[storage_tecs] * (s_opex[storage_tecs] + s_capex[storage_tecs]) * number_of_years for
                  storage_tecs in model.str))/1000

variable_cost = sum(sum(model.gene[tec, h] * vOM[tec] for h in model.h) for tec in model.tec)/ 1000
ll_cost = (sum(model.gene['ll', h] * vOM['ll'] for h in model.h))/ 1000
"""CONSTRAINT CREATION"""

model.generation_vre_constraint = \
    pyo.Constraint(model.h, model.vre, rule=generation_vre_constraint_rule)
model.generation_capacity_constraint = \
    pyo.Constraint(model.h, model.tec, rule=generation_capacity_constraint_rule)

model.battery_4_capacity_constraint = \
    pyo.Constraint(rule=battery4_capacity_constraint_rule)
model.combustion_2_constraint = \
    pyo.Constraint(model.h, rule=combustion_2_constraint_rule)
model.storing_constraint = \
    pyo.Constraint(model.h, model.str, rule=storing_constraint_rule)
model.storage_constraint = \
    pyo.Constraint(model.str, rule=storage_constraint_rule)
model.lake_reserve_constraint = \
    pyo.Constraint(model.months, rule=lake_reserve_constraint_rule)
model.stored_capacity_constraint = \
    pyo.Constraint(model.h, model.str, rule=stored_capacity_constraint)
model.storage_capacity_1_constraint = \
    pyo.Constraint(model.h, model.str, rule=storage_capacity_1_constraint_rule)
model.battery_capacity_constraint = \
    pyo.Constraint(model.battery, rule=battery_capacity_constraint_rule)
model.biogas_constraint = \
    pyo.Constraint(rule=biogas_constraint_rule)
model.adequacy_constraint = \
   pyo.Constraint(model.h, rule=adequacy_constraint_rule)
# Objective -> Cost
model.objective = pyo.Objective(rule=objective_rule)

"""INITIALISATING OUTPUTS"""

model_name = "Upgrade_Outputs"

technologies_definition = {
    # "offshore_f" : "floating offshore wind",
    # "offshore_g" : "ground-based offshore wind",
    "onshore": "onshore wind",
    "pv_g": "pv grounded",
    "pv_c": "pv commercial",
    "river": "run-of-river hydro",
    "lake": "lake and reservoirs",
    "biogas2": "biogas for ccgt",
    "ccgt": "combined cycle gas turbine",
    "nuc": "nuclear",
    "phs": "pumped hydroelectric energy storage",
    "battery4": "4 hours battery",
    # "SC" : "synchronous condenser",
}

"""SOLVE STATEMENT"""
opt = SolverFactory('gurobi')
results = opt.solve(model)
"""SET OUTPUTS VARIABLES"""

sumdemand = sum(demand[hour] for hour in model.h) / 1000

gene_tec = {}
for tec in model.tec:
    gene_tec[tec] = sum(pyo.value(model.gene[tec, hour]) for hour in model.h) / 1000
sumgene = sum(pyo.value(model.gene[gen, hour]) for hour in model.h for gen in model.gen) / 1000
reserve = {}


nSTORAGE = {}
for storage in model.str:
    for hour in model.h:
        nSTORAGE[(storage, hour)] = pyo.value(model.storage[storage, hour])

lcoe_sys1 = pyo.value(model.objective) * 1000 / sumgene

str_loss_percent = 100 * (sum(pyo.value(model.storage[storage, hour]) for storage in model.str for hour in model.h) - \
                          sum(gene_tec[storage] * 1000 for storage in model.str)) / (sumgene * 1000)


lc_percent = (100 * (sumgene - sumdemand ) / sumgene) - str_loss_percent
lc_TWh = (sumgene - sumdemand )

spot_price = {}
gas_price1 = {}
gas_price2 = {}
for hour in model.h:
    spot_price[hour] = - 1000000 * model.dual[model.adequacy_constraint[hour]]
    gas_price2[hour] = -1000000 * model.dual[model.combustion_2_constraint[hour]]

marginal_cost = sum(spot_price[hour] for hour in model.h) / (last_hour)

"""OUTPUTS
    There is 4 output files :
        - Summary           : A little summary with the cost and some others data
        - Hourly-Generation : Hourly data
        - Elec_Balance      : Electric Production and Consumption
        - Capacities        : List of capacities by technologies"""

"""OUTPUTS
    There is 4 output files :
        - Summary           : A little summary with the cost and some others data
        - Hourly-Generation : Hourly data
        - Elec_Balance      : Electric Production and Consumption
        - Capacities        : List of capacities by technologies"""




# Summary---------------------------------------------------------------------------------------------------------------
cost_dict= {}

cost_dict['total cost bEuro'] = pyo.value(model.objective) / number_of_years
cost_dict['variable cost bEuro'] = pyo.value(variable_cost)/number_of_years
cost_dict['fixed cost bEuro'] = pyo.value(fixed_cost)/number_of_years
cost_dict['ll cost'] = pyo.value(ll_cost)/number_of_years

dct1 = {k:[v] for k,v in cost_dict.items()}  # WORKAROUND
df_cost= pd.DataFrame(dct1)
df_cost.to_csv(r'outputs/cost_{}_{}_{}.csv'.format(sim_type,n,m))

# Elec_balance--------------------------------------------------------------------------------------------------------
balance_dict= {}

for tec in model.tec:
    balance_dict[tec] = sum (pyo.value(model.gene[tec,:]))/1000

dct1 = {k:[v] for k,v in balance_dict.items()}  # WORKAROUND
df_balance= pd.DataFrame(dct1)
df_balance.to_csv(r'outputs/balance_{}_{}_{}.csv'.format(sim_type,n,m))


# Capacities----------------------------------------------------------------------------------------------------------
capacity_dict= {}

for tec in model.tec:
    capacity_dict[tec] = pyo.value(model.capa[tec])

for str in model.str:
    capacity_dict[str+'p_d'] = pyo.value(model.s[str])    

for str in model.str:
    capacity_dict[str+'volume'] = pyo.value(model.capacity[str])

dct_capa = {k:[v] for k,v in capacity_dict.items()}  # WORKAROUND
df_balance= pd.DataFrame(dct_capa)
df_balance.to_csv(r'outputs/capacity_{}_{}_{}.csv'.format(sim_type,n,m))

# Hourly_Generation----------------------------------------------------------------------------------------------------

df_generation = pd.DataFrame()
for tec in model.tec:
 df_generation[tec] = pyo.value(model.gene[tec,:])

for str in model.str:
  df_generation[str+'soc'] = pyo.value(model.stored[str, :])

for str in model.str:
  df_generation[str+'ch p '] = pyo.value(model.storage[str, :])

df_generation.to_csv(r"outputs/generation_{}_{}_{}.csv".format(sim_type,n, m))

df_price = pd.DataFrame(spot_price.values())

df_price.to_csv(r"outputs/price_{}_{}_{}.csv".format(sim_type,n, m))
